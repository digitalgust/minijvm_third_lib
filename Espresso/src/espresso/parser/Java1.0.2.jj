/**
 *
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 * Copyright (C) 1998 Boston University
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Java files generated by running JavaCC on this file (or modified versions
 * of this file) may be used in exactly the same manner as Java files
 * generated from any grammar developed by you.
 *
 * Author: Sriram Sankar
 * Date: 6/11/96
 *
 * Author: Santiago M. Pericas
 * Date: 1/23/98
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 */

options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(JavaParser)

package espresso.parser;

import java.util.Vector;
import java.util.Enumeration;
import java.io.InputStream;
import java.math.BigInteger;

import espresso.Espresso;
import espresso.util.*;
import espresso.syntaxtree.*;
import espresso.classfile.Constants;
import espresso.parser.JavaImportManager;

public class JavaParser {

	/**
	  * The name of the default package
	  */
	final static String DEFAULT_PACKAGE = "";

	/**
	  * The name of the default super class
	  */
	final static String DEFAULT_SUPER = "java.lang.Object";

	/**
  	  * Symbol of the package that corresponds to the class being 
	  * defined or a default if no package declaration parsed.
 	  */
	Symbol packName_d = new Symbol(DEFAULT_PACKAGE);

	/**
	  * Name of the class (and of its superclass) being parsed.
	  */
	Symbol className_d = null;
	Symbol superName_d = new Symbol(DEFAULT_SUPER);

	/**
	  * This is the compiler's symbol table. 
	  */
	SymbolTable symbolTable_d = null;

	/**
	  * This is the compiler's import manager. 
	  */
	JavaImportManager importMgr_d = null;

	/**
	  * The name of the method being parsed.
	  */
	Symbol methodName_d = null;

	/**
	  * A pointer to the method declaration node of the method
	  * being parsed. This is used to create new MethodExpNodes.
	  */
	MethodDeclarationNode methodNode_d = null;

	/**
	  * During parsing, non-static initializers are collected 
	  * and at the end added to each constructor.
	  */
	BlockNode fieldInit_d = new BlockNode();

	/**
	  * During parsing, static initializers are collected and 
	  * at the end added to <clinit>.
	  */
	BlockNode staticInit_d = new BlockNode();

	/**
  	  * A String vector containing all the errors found during
	  * parsing.
	  */
	Vector errors_d = null;

	/**
	  *	A counter used to keep track of the different scopes
	  * within a method.
	  */
	IntegerStream counter_d = new IntegerStream();

	/**
	  * A stack used together with the counter to keep track
	  * of the scopes within a method.
	  */
	IntegerStack scopes_d = new IntegerStack();

	/**
	  * A stack used to match labels in break and continue
	  * statements with their corresponding labeled nodes.
	  */
	IntegerStack labels_d = new IntegerStack();

	/**
	  *	Keep track of references to forward types.
	  */
	Vector forwardTypes_d = new Vector();
	
	/**
	  * The pointer to the AST root node.
	  */
	CompilationUnitNode root_d = null;

	/**
	  * The main constructor.
	  */
	public JavaParser(InputStream stream, JavaImportManager importMgr, 
		SymbolTable symbolTable, Vector errors) 
	{
		this(stream);
		errors_d = errors;
		importMgr_d = importMgr;
		symbolTable_d = symbolTable;
	}

	/**
	  * This method is called to start parsing a file.
	  */
	public CompilationUnitNode parseProgram() throws ParseException {
		root_d = CompilationUnit();
		checkCloseProgram();
		return (errors_d.size() > 0) ? null : root_d;
	}
	
    /**
      * Sets source coordinates for error reporting.
      */
	public void recordSourceCoord(SyntaxTreeNode node, Token token) {
		if (node != null) {
			node.line_d = token.beginLine;
		}
    }

	/**
	  * Verify that any forward references to types were resolved.
	  */
	private void checkCloseProgram() {
		int n = forwardTypes_d.size();
		for (int i = 0; i < n; i++) {
			Symbol tname = (Symbol) forwardTypes_d.elementAt(i);
			if (symbolTable_d.lookupType(tname) == null) {
				ErrorMsg error = new ErrorMsg(ErrorMsg.NOTCLASS_ERR, 0);	
				errors_d.addElement(error.toString(tname.toString()));
			}
		}
	}

	/**
	  *	Adds a default constructor when needed.
	  */
	private void addDefaultConstructor(ClassDeclarationNode node) {
		boolean defined = false;
		int n = node.body_d.size();

		for (int i = 0; i < n; i++) {
			ClassBodyDeclarationNode cbnode = (ClassBodyDeclarationNode)
				node.body_d.elementAt(i);
			if (cbnode instanceof ConstructorDeclarationNode) {
				defined = true;
				break;
			}
		}

		if (!defined) {
			ConstructorDeclarationNode cnode = new ConstructorDeclarationNode();
			cnode.name_d = new Symbol(className_d, cnode.name_d);		// adds <init>
			cnode.formals_d = cnode.exceptions_d = new Vector(1);
			cnode.encodeType(); 
			cnode.block_d = new BlockNode();
			cnode.accessFlags_d = Constants.ACC_PUBLIC;
			cnode.consInvocation_d = new ConstructorInvocationNode();
			cnode.consInvocation_d.name_d = superName_d;				// call to super()

			// Add it to the class and the symbol table
			symbolTable_d.addMethod(cnode.name_d, cnode);
			node.body_d.addElement(cnode);
		}
	}

	/**
	  *	Adds a <clinit> if static initializations were collected along 
	  * the way.
	  */
	private void createStaticInit(ClassDeclarationNode node) {
		int n = staticInit_d.numberOfStatments();

		if (n > 0) {	
			MethodDeclarationNode mnode = new MethodDeclarationNode();
			mnode.name_d = new Symbol(className_d, "<clinit>");
			mnode.formals_d = mnode.exceptions_d = new Vector(1);
			mnode.type_d = Type.Void;
			mnode.encodeType(); 
			mnode.block_d = new BlockNode();
			mnode.accessFlags_d = Constants.ACC_STATIC;

			// Add it to the class and the symbol table
			symbolTable_d.addMethod(mnode.name_d, mnode);
			node.body_d.addElement(mnode);
			
			for (int j = 0; j < n; j++) {
				mnode.block_d.addStatement(staticInit_d.statementAt(j));
			} 						
			staticInit_d.reset();
		}
	}

	/**
	  * Copies all field initializers collected during paring to each
	  * of the constructors found.
	  */
	private void copyInitializers(ClassDeclarationNode node) {
		int n = node.body_d.size();

		for (int i = 0; i < n; i++) {
			ClassBodyDeclarationNode cbnode = 
				(ClassBodyDeclarationNode) node.body_d.elementAt(i);

			if (cbnode instanceof ConstructorDeclarationNode) {
				ConstructorDeclarationNode cnode =
					(ConstructorDeclarationNode) cbnode;

				int m = fieldInit_d.numberOfStatments();
				for (int j = 0; j < m; j++) {
					StatementExpNode snode = 
						(StatementExpNode) fieldInit_d.statementAt(j);
					AssignmentNode anode = (AssignmentNode) snode.expression_d;

					// Update the methodNode_d pointer of the field exp
					((FieldExpNode) anode.left_d).methodNode_d = cnode;
					cnode.fieldInit_d.addStatement(snode);
				} 						
			}
		}
		fieldInit_d.reset();
	}


	/**
	  * Determines whether a given unqualified name refers to a local, 
	  * a parameter, a field or a type. The symbol table, the name of 
	  * the method being parsed, the stack of scopes and the import 
	  * declarations are used for this purpose.
	  */
	private ExpressionNode classifySimpleName(Symbol name) {
		SyntaxTreeNode aux = null;
		ExpressionNode result = null;

		// First search for a local variable

		Symbol nname = null;
		Integer scope = null;
		IntegerStack st = (IntegerStack) scopes_d.clone();

		while (result == null && !st.empty()) {
			scope = st.popInteger();
			nname = new Symbol(methodName_d, scope, name);

			aux = symbolTable_d.lookupLocal(nname);
			if (aux != null) {
				result = new LocalExpNode(nname);
			} 
		}

		// Inspect the last scope to see if it was a parameter

		if (result == null && scope != null) {
			aux = symbolTable_d.lookupFormal(nname);
			if (aux != null) {
				result = new FormalExpNode(nname);
			}
		}

		// Look for a field in the class or any super type

		if (result == null) {
			ClassType ctype = Type.createClassType(className_d);

			try {
				nname = ctype.findField(name);
				if (nname != null) {
					String path = nname.pathName();
					if (path.equals(className_d.toString())) {
						result = new FieldExpNode(new ThisExpNode(className_d), name,
							methodNode_d);
					}
					else {
						// Keep the name of the class where the field was found
						result = new FieldExpNode(new SuperExpNode(path), name,
							methodNode_d);
					}
				}
			}
			catch (AmbiguousName e) {
				// TODO -> push an error
			}
		}

		// Let us now check if it is a type

		if (result == null) {
			result = findTypeName(name, false);
		}

		// If everything else failed, then it must be a package name

		return (result == null) ? new PackageExpNode(name) : result;
	}

	/**
	  * Check if the name refers to a valid type (class or interface)
	  * by using the import declarations. The name may can be qualified 
	  * or not.
	  */
	private ExpressionNode findTypeName(Symbol name, boolean forward) {
		SyntaxTreeNode aux = null;
		ExpressionNode result = null;

		// Check current class, super class and single-type-imports

		if (name.equals(className_d.baseName()) || name.equals(className_d)) {
			result = new TypeExpNode(className_d);
		}
		else if (name.equals(superName_d.baseName()) || name.equals(superName_d)) {
			result = new TypeExpNode(superName_d);
		}
		else {
			int size = root_d.imports_d.size();

			for (int i = 0; i < size; i++) {
				Symbol imp = (Symbol) root_d.imports_d.elementAt(i);
				String baseName = imp.baseName();

				if (name.equals(imp.baseName()) || name.equals(imp)) {
					result = new TypeExpNode(imp);
				}
			}
		}

		// Types in the same CU have implicit imports. 

		if (result == null) {
			int size = root_d.types_d.size();

			for (int i = 0; i < size; i++) {
				TypeDeclarationNode node = 
					(TypeDeclarationNode) root_d.types_d.elementAt(i);
				String baseName = node.name_d.baseName();

				if (name.equals(baseName) || name.equals(node.name_d)) {

					// Check to see if the name is ambiguous

					if (result != null) {
						ErrorMsg error = new ErrorMsg(ErrorMsg.AMBITYPE_ERR, 
							token.beginLine);
						errors_d.addElement(error.toString(baseName));
					}
					else {
						result = new TypeExpNode(node.name_d);
					}
				}
			}
		}

		// Finally we check for import-on-demand and fully qualified names

		if (result == null) {
             try {
				Symbol fullName = null;

				if (name.isQualified()) {
					if (importMgr_d.existsClass(name)) {
						fullName = name;
					}
					else {
						ErrorMsg error = new ErrorMsg(ErrorMsg.NOTCLASS_ERR, 
							token.beginLine);	
						errors_d.addElement(error.toString(name.toString()));
					}
				}
				else {
					fullName = importMgr_d.fullyQualifyName(name);
				}

				if (fullName != null) {
					result = new TypeExpNode(fullName);
					importMgr_d.readClassFile(fullName, false);
				}
             }
             catch (Exception e) {
				ErrorMsg error = new ErrorMsg(ErrorMsg.AMBITYPE_ERR, 
								token.beginLine);
				errors_d.addElement(error.toString(e.getMessage()));
             }
		}

		// Add a forward ref if this is supposed to be a type

		if (result == null && forward) {
			Symbol fullName = new Symbol(packName_d, name);
			forwardTypes_d.addElement(fullName);			// keep track of it
			result = new TypeExpNode(fullName);
		}	

		return result;
	}

	/**
	  * Adds the local vars to the symbol table
	  */
	private void declareLocalVars(LocalVarDeclarationNode node) {
		VariableDeclaratorNode var;
		LocalVarDeclarationNode aux = null;
		Integer scope = scopes_d.peekInteger();

		int n = node.locals_d.size();
		for (int i = 0; i < n; i++) {
			var = (VariableDeclaratorNode) node.locals_d.elementAt(i);

			// Fix local var name adding scope

			var.name_d = new Symbol(methodName_d, scope, var.name_d.baseName());

			// First look for a param with the same name

			FormalParameterNode fmt = 
				symbolTable_d.lookupFormal(var.name_d);

			if (fmt == null) {

				// Check if this var is shadowing another var

				IntegerStack st = (IntegerStack) scopes_d.clone();

				while (!st.empty()) {
					Integer nscope = st.popInteger();
					Symbol name = new Symbol(methodName_d, nscope, 
						var.name_d.baseName());

					aux = symbolTable_d.lookupLocal(name);
					if (aux != null) {
						ErrorMsg error = new ErrorMsg(ErrorMsg.LOCALDEF_ERR, 
							token.beginLine);
						errors_d.addElement(error.toString(var.name_d.baseName()));
					}
				}

				symbolTable_d.addLocal(var.name_d, node);
			} 
			else {
				ErrorMsg error = new ErrorMsg(ErrorMsg.LOCALDEF_ERR, 
					token.beginLine);
				errors_d.addElement(error.toString(var.name_d.baseName()));
			}
		}
	}

	/**
	  * Used to load classes found in ClassDeclaration and InterFaceDeclaration
	  */
	private void readClassesUpToRoot(Symbol name, SyntaxTreeNode node) {

		// First check if defined in the same CU

		int size = root_d.types_d.size();
		for (int i = 0; i < size; i++) {
			TypeDeclarationNode tnode = 
				(TypeDeclarationNode) root_d.types_d.elementAt(i);
			String baseName = tnode.name_d.baseName();

			if (name.equals(baseName) || name.equals(tnode.name_d)) {
				return;			// no need to load it !
			}
		}

		// Now check if they are forward refs

		size = forwardTypes_d.size();
		for (int i = 0; i < size; i++) {
			Symbol fname = (Symbol) forwardTypes_d.elementAt(i);
			String baseName = fname.baseName();
			
			if (name.equals(baseName) || name.equals(fname)) {
				return;			// no need to load it !
			}
		}

		// If not, try to load its class file

		if (!name.isQualified()) {
            try {
             	Symbol fullName = importMgr_d.fullyQualifyName(name);
             	if (fullName != null) {
             		importMgr_d.readClassFile(fullName, true);
             	}
             	else {
					ErrorMsg error = new ErrorMsg(ErrorMsg.NOTCLASS_ERR, 
						node.line_d);	
					errors_d.addElement(error.toString(name.toString()));
             	}
             }
             catch (Exception e) {
				ErrorMsg error = new ErrorMsg(ErrorMsg.AMBITYPE_ERR, 
								node.line_d);
				errors_d.addElement(error.toString(e.getMessage()));
             }
		}
		else if (!importMgr_d.existsClass(name)) {
			ErrorMsg error = new ErrorMsg(ErrorMsg.NOTCLASS_ERR, 
				node.line_d);	
			errors_d.addElement(error.toString(name.toString()));
		}
		else {
			importMgr_d.readClassFile(name, true);
		}
	} 

	/*
	 * This predicate is used by the StatementExp() production as a result
	 * of a limitation in the grammar.
	 */
	private boolean statementExp(ExpressionNode node) {
		return (node instanceof PreIncrementExpNode || node instanceof PreDecrementExpNode 
 		 || node instanceof PostIncrementExpNode || node instanceof PostDecrementExpNode
		 || node instanceof AssignmentNode || node instanceof MethodExpNode  
		 || node instanceof AllocationExpNode);
	}

}

PARSER_END(JavaParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

CompilationUnitNode CompilationUnit() :
{ 
	Symbol imp;
	TypeDeclarationNode typ;
	CompilationUnitNode node = new CompilationUnitNode(); 

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));
		
	// Link the tree from the root_d field
	root_d = node;
}
{
  [ PackageDeclaration(node) ] 

  ( imp = ImportDeclaration() 
	{ 
		if (!imp.toString().endsWith("*")) { 
			if (!node.imports_d.contains(imp)) {
				node.imports_d.addElement(imp);

				// Verify the single-imports are correct

				if (!importMgr_d.existsClass(imp)) {
					ErrorMsg error = new ErrorMsg(ErrorMsg.NOTCLASS_ERR, 
						node.line_d);	
					errors_d.addElement(error.toString(imp.toString()));
				}
				else {
					importMgr_d.readClassFile(imp, false);
				}
			}
		}
		else { 
			// Qualified imports are handled by the ImportManager
			importMgr_d.addQualifiedImport(imp);
		}
	} )*

	{
		/* 
		 * Either add to the qualified imports the name of the package
		 * followed by '*' or simply a '*' if no package was specified.
		 */
		imp = packName_d.equals(DEFAULT_PACKAGE) ? new Symbol("*") 
			: new Symbol(packName_d, "*");
		importMgr_d.addQualifiedImport(imp);
	}

  ( typ = TypeDeclaration()	{ node.types_d.addElement(typ); } )*

  <EOF>

	{ return node; }
}

void PackageDeclaration(CompilationUnitNode node) :
{}
{
  "package" ( node.packName_d = Name() ) ";"
	{ 
		symbolTable_d.addPackage(node.packName_d, node);
		packName_d = node.packName_d; 
	}
}

Symbol ImportDeclaration() :
{
	Symbol result;
}
{
  "import" ( result = Name() ) 
  	[ "." "*" { result = new Symbol(result, "*"); } ] ";"

	{ return result; }
}

TypeDeclarationNode TypeDeclaration() :
{
	TypeDeclarationNode node = null;
}
{
  ( LOOKAHEAD( ( "abstract" | "final" | "public" )* "class" )
    ( node = ClassDeclaration() )
   |
    ( node = InterfaceDeclaration() )
   |
     ";" )

	{ return node; }
}


/*
 * Declaration syntax follows.
 */

ClassDeclarationNode ClassDeclaration() :
{
	ClassBodyDeclarationNode decl;
	ClassDeclarationNode node = new ClassDeclarationNode();
	node.superName_d = new Symbol(DEFAULT_SUPER);

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));
	
}
{
  ( ( "abstract" { node.accessFlags_d |= Constants.ACC_ABSTRACT; }
    | "final"  	 { node.accessFlags_d |= Constants.ACC_FINAL; }
    | "public" 	 { node.accessFlags_d |= Constants.ACC_PUBLIC; } )*

      "class" <IDENTIFIER> 
	  { 
		className_d = node.name_d = new Symbol(packName_d, token.image); 
		SyntaxTreeNode aux =
			symbolTable_d.addType(node.name_d, node);
		if (aux != null) {
			ErrorMsg error = new ErrorMsg(ErrorMsg.CLASSDEF_ERR, token.beginLine);
			errors_d.addElement(error.toString(node.name_d.baseName()));
		}
	  } 

      [ "extends" ( node.superName_d = ResolvedName() ) 
		{ superName_d = node.superName_d;} ]
	  { readClassesUpToRoot(node.superName_d, node); } 

      [ "implements" ( node.interfaces_d = ResolvedNameList() )
	  { 
		for (Enumeration e = node.interfaces_d.elements(); e.hasMoreElements();) {
			Symbol unit = (Symbol) e.nextElement();
			readClassesUpToRoot(unit, node); 
	   	} 
	  } ]

    "{" ( decl = ClassBodyDeclaration() 
		{ node.body_d.addElement(decl); } )* "}" )

	{ 
		addDefaultConstructor(node);
		createStaticInit(node);
		copyInitializers(node);
		return node; 
	} 
}

ClassBodyDeclarationNode ClassBodyDeclaration() :
{
	ClassBodyDeclarationNode node = null;
}
{
  ( LOOKAHEAD(2)
    node = StaticInitializer()
  |
    LOOKAHEAD( [ "public" | "protected" | "private" ] Name() "(" )
    ( node = ConstructorDeclaration() )
  |
    LOOKAHEAD( MethodDeclarationLookahead() )
    ( node = MethodDeclaration() )
  |
    ( node = FieldDeclaration() ) )

	{ return node; }
}

/*
 * This production is to determine lookahead only.
 * Hence, no node is generated in the AST for it. (Santiago)
 */
void MethodDeclarationLookahead() :
{}
{
  ( "public" | "protected" | "private" | "static" | "abstract" | "final" 
    | "native" | "synchronized" )*
  ResultTypeExp() <IDENTIFIER> "("
}

InterfaceDeclarationNode InterfaceDeclaration() :
{
	ClassBodyDeclarationNode decl;
	InterfaceDeclarationNode node = new InterfaceDeclarationNode();

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));
}
{
  ( ( "abstract" { node.accessFlags_d |= Constants.ACC_ABSTRACT; }
	| "public"   { node.accessFlags_d |= Constants.ACC_PUBLIC; } )*

      "interface" <IDENTIFIER> 
	  { 
		className_d = node.name_d = new Symbol(packName_d, token.image); 
		SyntaxTreeNode aux =
			symbolTable_d.addType(node.name_d, node);
		if (aux != null) {
			ErrorMsg error = new ErrorMsg(ErrorMsg.INTERDEF_ERR, token.beginLine);
			errors_d.addElement(error.toString(node.name_d.baseName()));
		}
	  }

	  [ "extends" ( node.interfaces_d = ResolvedNameList() ) 
	  		  { for (Enumeration e = node.interfaces_d.elements(); e.hasMoreElements();) {
							Symbol unit = (Symbol) e.nextElement();
							readClassesUpToRoot(unit,node); 
					} } ]

      "{" ( decl = InterfaceMemberDeclaration() 
			{ node.body_d.addElement(decl); } )* "}" )

	{ 
		return node; 
	} 
}

/*
 * Productions 'MethodDeclaration()' and 'FieldDeclaration()' are reused
 * at this point. Hence, so is the type 'ClassBodyDeclarationNode'.
 */
ClassBodyDeclarationNode InterfaceMemberDeclaration() :
{
	ClassBodyDeclarationNode node = null;
}
{
  ( LOOKAHEAD( MethodDeclarationLookahead() )
  ( node = MethodDeclaration() 
	{ 
		node.accessFlags_d = (Constants.ACC_ABSTRACT 
			| Constants.ACC_PUBLIC); 
	} )
  |
  ( node = FieldDeclaration() 
	{ 
		node.accessFlags_d = (Constants.ACC_STATIC 
			| Constants.ACC_FINAL | Constants.ACC_PUBLIC); 
	} ) )

	{ return node; }
}

FieldDeclarationNode FieldDeclaration() :
{
	VariableDeclaratorNode var;
	FieldDeclarationNode node = new FieldDeclarationNode();	
	Token token = getToken(1);
    // Add source code info for error reporting
	recordSourceCoord(node, token);
}
{
  ( "public" 		{ node.accessFlags_d |= Constants.ACC_PUBLIC; }
  | "protected" 	{ node.accessFlags_d |= Constants.ACC_PROTECTED; }
  | "private"    	{ node.accessFlags_d |= Constants.ACC_PRIVATE; }
  | "static"     	{ node.accessFlags_d |= Constants.ACC_STATIC; }
  | "final"      	{ node.accessFlags_d |= Constants.ACC_FINAL; }
  | "transient"  	{ node.accessFlags_d |= Constants.ACC_TRANSIENT; }
  | "volatile"   	{ node.accessFlags_d |= Constants.ACC_VOLATILE; } )*

  ( node.type_d = TypeExp() )
  ( var = VariableDeclarator(true) ) { node.fields_d.addElement(var); }
  ( "," ( var = VariableDeclarator(true) ) { node.fields_d.addElement(var); } )* ";" 

	{ 
		node.encodeType();

		/*
		 * Adds the fields to the symbol table
		 */
		int n = node.fields_d.size(); 					// TODO check forward references
		for (int i = 0; i < n; i++) {
			var = (VariableDeclaratorNode) node.fields_d.elementAt(i);
			
			FieldDeclarationNode aux = 
				symbolTable_d.addField(var.name_d, node);
			if (aux != null) {
				ErrorMsg error = new ErrorMsg(ErrorMsg.FIELDDEF_ERR, 
					token.beginLine);
				errors_d.addElement(error.toString(var.name_d.baseName()));
			}

			/*
			 * Add field initializers to either fieldInit_d or staticInit_d except
			 * when the field is final and initialized by a literal. In this case 
		 	 * the literal is always fetched directly from the CP and, hence, the
			 * actual field never accessed.
			 */
			if (var.init_d != null && !(node.isFinal() && var.init_d instanceof Literal)) {
				ExpressionNode left;
				if (node.isStatic()) {
					left = new TypeExpNode(var.name_d.pathName());					
				} else {
					left = new ThisExpNode(var.name_d.pathName());
				}
				recordSourceCoord(left, token);
				FieldExpNode field = new FieldExpNode(left, var.name_d.baseName(),
					methodNode_d);
				recordSourceCoord(field, token);
				field.leftValue_d = true;

				AssignmentNode ass = new AssignmentNode(field, var.init_d);
				ass.operator_d = Operators.EQ;
				ass.statementExp_d = true;			// avoid needless DUPS
				recordSourceCoord(ass, token);
				if (node.isStatic()) {
					staticInit_d.addStatement(new StatementExpNode(ass));
				} else {
					fieldInit_d.addStatement(new StatementExpNode(ass));
				}				
			}
		}

		return node; 
	}
}

VariableDeclaratorNode VariableDeclarator(boolean fieldFlag) :
{
	Symbol name;
	VariableDeclaratorNode node = new VariableDeclaratorNode(fieldFlag);

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));
}
{
  ( name = VariableDeclaratorId() )
	{ node.name_d = new Symbol(className_d, name); } 
  [ "=" node.init_d = VariableInitializer() ]

	{ return node; }
}

Symbol VariableDeclaratorId() :
{
	String result;
}
{
  <IDENTIFIER> { result = token.image; } ( "[" "]" { result += "["; } )*
	{ return new Symbol(result); }
}

ExpressionNode VariableInitializer() :
{	
	ExpressionNode node = null;
	Token token = getToken(1);
    ExpressionNode ainit = null;
    Vector initlist = null;
}


{
  ("{" [ ainit = VariableInitializer() 
	 { initlist = new Vector(5); initlist.addElement(ainit); }
      ( LOOKAHEAD(2) "," ainit = VariableInitializer() 
     { initlist.addElement(ainit); })* ] [ "," ] "}"
     { node = new ArrayInitializerNode(initlist); }
  |
    node = Expression() )
 	
 	{   recordSourceCoord(node, token);
 		return node; }
}

MethodDeclarationNode MethodDeclaration() :
{
	MethodDeclarationNode node = new MethodDeclarationNode();

	// Update the pointer to the current method
	methodNode_d = node;

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));

	// Start a new scope at this point
	node.scope_d = scopes_d.pushInteger(counter_d.next());
}
{
  ( "public" 		{ node.accessFlags_d |= Constants.ACC_PUBLIC; }
  | "protected" 	{ node.accessFlags_d |= Constants.ACC_PROTECTED; }
  | "private"    	{ node.accessFlags_d |= Constants.ACC_PRIVATE; }
  | "static"     	{ node.accessFlags_d |= Constants.ACC_STATIC; }
  | "abstract"  	{ node.accessFlags_d |= Constants.ACC_ABSTRACT; }
  | "final"      	{ node.accessFlags_d |= Constants.ACC_FINAL; }
  | "native"   		{ node.accessFlags_d |= Constants.ACC_NATIVE; } 
  | "synchronized"  { node.accessFlags_d |= Constants.ACC_SYNCHRONIZED; } )*

  ( node.type_d = ResultTypeExp() ) MethodDeclarator(node) 
  	{ 
		node.encodeType(); 
		Vector methods = symbolTable_d.lookupMethod(node.name_d);
		if (methods != null) {
			int size = methods.size();
			for (int i = 0; i < size; i++) {
				MethodDeclarationNode mnode = (MethodDeclarationNode)
					methods.elementAt(i);

				// Compare types modulo return types
				MethodType mtype = (MethodType) node.type_d;
				if (mtype.identicalTo(mnode.type_d, true)) {
					ErrorMsg error = new ErrorMsg(ErrorMsg.DUPMETHD_ERR, 
						token.beginLine);
					errors_d.addElement(error.toString(node.name_d.baseName()));
				}
			}
		}
		symbolTable_d.addMethod(node.name_d, node); 
	}

  [ "throws" ( node.exceptions_d = ResolvedNameList() ) ]

  ( node.block_d = Block(false) | ";" )

	{ 
		// Reset the pointer to the current method
		methodNode_d = null;

		scopes_d.popInteger();			// end scope
		return node; 
	}
}

void MethodDeclarator(MethodDeclarationNode node) :
{
	String name;
}
{
  ( <IDENTIFIER> )
	{ 	
		name = token.image; 
		methodName_d = node.name_d = new Symbol(className_d, name);
	}
  ( node.formals_d = FormalParameters() )
  ( "[" "]" { name += "["; } )*
}

Vector FormalParameters() :
{
	FormalParameterNode fml;
	Vector formals = new Vector();
}
{
  "(" [ ( fml = FormalParameter()  { formals.addElement(fml); } )
   ( "," ( fml = FormalParameter() { formals.addElement(fml); } ) )* ] ")"

	{ return formals; }
}

FormalParameterNode FormalParameter() :
{
	Symbol name;
	Integer scope = scopes_d.peekInteger();
	FormalParameterNode node = new FormalParameterNode();

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));
}
{
  ( node.type_d = TypeExp() ) ( name = VariableDeclaratorId() ) 

	{ 
		// Create a formal with the method name and the scope
		node.name_d = new Symbol(methodName_d, scope, name);

		node.encodeType();

		FormalParameterNode aux;
		aux = symbolTable_d.addFormal(node.name_d, node);
		if (aux != null) {
			ErrorMsg error = new ErrorMsg(ErrorMsg.LOCALDEF_ERR, 
				token.beginLine);
			errors_d.addElement(error.toString(node.name_d.baseName()));
		}
		return node; 
	}
}

ConstructorDeclarationNode ConstructorDeclaration() :
{
	StatementNode bstmt;
	BlockNode blockNode = new BlockNode();
	ConstructorDeclarationNode node = new ConstructorDeclarationNode();

	// Update the pointer to the current method
	methodNode_d = node;

	// Default call to super
	node.consInvocation_d = new ConstructorInvocationNode(superName_d);

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));

	// Start a new scope at this point
	node.scope_d = scopes_d.pushInteger(counter_d.next());
}
{
  [ "public" 		{ node.accessFlags_d |= Constants.ACC_PUBLIC; }
  | "protected" 	{ node.accessFlags_d |= Constants.ACC_PROTECTED; }
  | "private"    	{ node.accessFlags_d |= Constants.ACC_PRIVATE; } ]

  <IDENTIFIER>
	{ methodName_d = node.name_d = new Symbol(className_d, node.name_d); }

  ( node.formals_d = FormalParameters() )
	{ node.encodeType(); symbolTable_d.addMethod(node.name_d, node); }

  [ "throws" ( node.exceptions_d = ResolvedNameList() ) ]

  "{" [ LOOKAHEAD(2) node.consInvocation_d = ConstructorInvocation() ]
      ( bstmt = BlockStatement(true) { blockNode.stmts_d.addElement(bstmt); } )* 
  "}"

	{ 
		// Reset the pointer to the current method
		methodNode_d = null;

		node.block_d = blockNode;		// link the main block
		scopes_d.popInteger();			// end scope
		return node; 
	}
}

ConstructorInvocationNode ConstructorInvocation() :
{
	ConstructorInvocationNode node = new ConstructorInvocationNode();

    // Add source code info for error reporting
	recordSourceCoord(node, getToken(1));
}
{
 ( "this" ( node.args_d = Arguments() 
	{ node.invocationThis_d = true; node.name_d = className_d;} ) ";"
  |
  "super" ( node.args_d = Arguments() 
    { node.name_d = superName_d; } )  ";" )

	{ return node; }
}

StaticInitializerNode StaticInitializer() :
{	
	StaticInitializerNode node = new StaticInitializerNode();
	methodName_d = new Symbol("<clinit>");

	// Start a new scope at this point
	scopes_d.pushInteger(counter_d.next());
}
{
  "static" ( node.block_d = Block(false) )
	{ 
		/*
		 * Add the statements defined in this block to the staticInit_d
		 * block where all the initializations are collected.
		 */
		int n = node.block_d.numberOfStatments();
		for (int i = 0; i < n; i++) {
			staticInit_d.addStatement(node.block_d.statementAt(i));
		} 
		scopes_d.popInteger();		// end scope
		return node; 
	}  
}


/*
 * Type, name and expression syntax follows.
 */
Type TypeExp() :
{
	Type result;
	Symbol name;
	int dims = 0;
}
{
  ( ( name = ResolvedName() )
	{ result = new ClassType(name); }
  | 
    ( result = PrimitiveTypeExp() ) ) ( "[" "]" { dims++; } )* 

	{
		if (dims > 0) {
			result = new ArrayType(result, dims);
		}
		return result;
	}
}

Type PrimitiveTypeExp() :
{}
{
  "boolean"		{ return Type.Boolean; }
|
  "char"		{ return Type.Char; }
|
  "byte"		{ return Type.Byte; }
|
  "short"		{ return Type.Short; }
|
  "int"			{ return Type.Int; }
|
  "long"		{ return Type.Long; }
|
  "float"		{ return Type.Float; }
|
  "double"		{ return Type.Double; }
}

Type ResultTypeExp() :
{
	Type result;
}
{
  "void"		{ return Type.Void; }
|
  ( result = TypeExp() )  { return result; }		
}

Symbol Name() :
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
	String result;
}
{
  <IDENTIFIER> { result = token.image; }
  ( LOOKAHEAD(2) "." <IDENTIFIER> { result += "." + token.image; } )*

 	{ return new Symbol(result); }
}

Symbol ResolvedName()  :
{
	Symbol name;
}
{
	( name = Name() )
	{
		// If not a type, a forward ref is created by findTypeName()

		ExpressionNode node = findTypeName(name, true);
		if (node instanceof TypeExpNode) {
			name = ((TypeExpNode) node).toSymbol();
		}
		else if (node instanceof ThisExpNode) {
			name = className_d;
		}
		else if (node instanceof SuperExpNode) {
			name = superName_d;
		}

		return name;
	}
}

Vector ResolvedNameList() :
{
	Symbol name;
	Vector result = new Vector(5);
}
{
  ( name = ResolvedName() ) { result.addElement(name); }
  ( "," ( name = ResolvedName() ) { result.addElement(name); } )* 

	{ return result; }
}

/*
 * Expression syntax follows.
 */

ExpressionNode Expression() :
{
	ExpressionNode node;
	Token token = getToken(1);
}
{
  ( LOOKAHEAD( PrimaryExp() AssignmentOperator() )
  ( node = Assignment() )
|
  ( node = ConditionalExp() ) )

	{ recordSourceCoord(node, token); return node; }
}

ExpressionNode Assignment() :
{
	AssignmentNode node = new AssignmentNode();
	recordSourceCoord(node, getToken(1));
}
{
  ( node.left_d = PrimaryExp() ) 
  ( node.operator_d = AssignmentOperator() )
  ( node.right_d = Expression() )

	{ 
		// This is needed for chained assignments
		if (node.right_d instanceof AssignmentNode) {
			AssignmentNode anode = (AssignmentNode) node.right_d;
			anode.parent_d = node;			// needed for dups
		}

		// Left flag set here
		node.left_d.leftValue_d = true;
		return node; 
	}
}

int AssignmentOperator() :
{
	int result;
}
{
  ( "="  	{ result = Operators.EQ; }
  | "*=" 	{ result = Operators.TS_EQ; }
  | "/=" 	{ result = Operators.DV_EQ; }
  | "%=" 	{ result = Operators.MD_EQ; }
  | "+=" 	{ result = Operators.PS_EQ; }
  | "-=" 	{ result = Operators.MS_EQ; }
  | "<<=" 	{ result = Operators.SL_EQ; }
  | ">>=" 	{ result = Operators.SR_EQ; }
  | ">>>=" 	{ result = Operators.SS_EQ; }
  | "|=" 	{ result = Operators.OR_EQ; } 
  | "&=" 	{ result = Operators.AND_EQ; }
  | "^=" 	{ result = Operators.XOR_EQ; } )

	{ return result; }
}

ExpressionNode ConditionalExp() :
{
	ExpressionNode node, falseCase, trueCase;
}
{
  ( node = ConditionalOrExp() ) 
  [ "?" ( trueCase = Expression() ) ":" 
        ( falseCase = ConditionalExp() ) 
        { node = new ConditionalExpNode(node, trueCase, falseCase); } ]

	{ return node; }
}

ExpressionNode ConditionalOrExp() :
{
	ExpressionNode node, left, right;
}
{
  ( left = ConditionalAndExp() { node = left; } )
  ( "||" ( right = ConditionalAndExp() ) 
         { left = node = new ConditionalOrExpNode(left, right); } )*

	{ return node; }
}

ExpressionNode ConditionalAndExp() :
{
	ExpressionNode node, left, right;
}
{
  ( left = InclusiveOrExp() { node = left; } )
  ( "&&" ( right = InclusiveOrExp() ) 
         { left = node = new ConditionalAndExpNode(left, right); } )*

	{ return node; }
}

ExpressionNode InclusiveOrExp() :
{
	ExpressionNode node, left, right;
}
{
  ( left = ExclusiveOrExp() { node = left; } ) 
  ( "|" ( right = ExclusiveOrExp() ) 
        { left = node = new InclusiveOrExpNode(left, right); } )*

	{ return node; }
}

ExpressionNode ExclusiveOrExp() :
{
	ExpressionNode node, left, right;
}
{
  ( left = AndExp() { node = left; } )
  ( "^" ( right = AndExp() ) 
        { left = node = new ExclusiveOrExpNode(left, right); } )*

	{ return node; }
}

ExpressionNode AndExp() :
{
	ExpressionNode node, left, right;
}
{
  ( left = EqualityExp() { node = left; } )
  ( "&" ( right = EqualityExp() ) 
        { left = node = new AndExpNode(left, right); } )*

	{ return node; }
}

ExpressionNode EqualityExp() :
{
	int operator;
	ExpressionNode node, left, right;
}
{
  ( left = InstanceOfExp() { node = left; } )
  ( ( "==" { operator = Operators.EQ_EQ; }
    | "!=" { operator = Operators.NEQ_EQ; } ) 
  ( right = InstanceOfExp() ) 
		{ left = node = new EqualityExpNode(left, right, operator); } )*

	{ return node; }
}

ExpressionNode InstanceOfExp() :
{
	Type type;
	ExpressionNode node, left;
}
{
  ( left = RelationalExp() { node = left; } )
  [ "instanceof" ( type = TypeExp() ) { node = new InstanceOfExpNode(left, type); } ]

	{ return node; }
}

ExpressionNode RelationalExp() :
{
	int operator;
	ExpressionNode node, left, right;
}
{
  ( left = ShiftExp() { node = left; } ) 
  ( ( "<"  { operator = Operators.LT; } 
    | ">"  { operator = Operators.GT; }
    | "<=" { operator = Operators.LT_EQ; }
    | ">=" { operator = Operators.GT_EQ; } ) 
  ( right = ShiftExp() ) 
		{ left = node = new RelationalExpNode(left, right, operator); } )*

	{ return node; }
}

ExpressionNode ShiftExp() :
{
	int operator;
	ExpressionNode node, left, right;
}
{
  ( left = AdditiveExp() { node = left; } )
  ( ( "<<"  { operator = Operators.SL; } 
    | ">>"  { operator = Operators.SR; }
    | ">>>" { operator = Operators.SS; } ) 
  ( right = AdditiveExp() )
		{ left = node = new ShiftExpNode(left, right, operator); } )*

	{ return node; }
}

ExpressionNode AdditiveExp() :
{
	int operator;
	ExpressionNode node, left, right;
}
{
  ( left = MultiplicativeExp() { node = left; } )
  ( ( "+" { operator = Operators.PS; } 
    | "-" { operator = Operators.MS; } ) 
  ( right = MultiplicativeExp() )
		{ left = node = new AdditiveExpNode(left, right, operator);
		  if (((AdditiveExpNode)node).left_d instanceof AdditiveExpNode) {
		       AdditiveExpNode addexpnode = 
				       (AdditiveExpNode)((AdditiveExpNode)node).left_d;
                       addexpnode.parent_d = node;
		 /*    ((AdditiveExpNode)node).parent_d = ((AdditiveExpNode)node).left_d;*/
		  } } )*

	{ recordSourceCoord(node, getToken(1)); return node; }
}

ExpressionNode MultiplicativeExp() :
{
	int operator;
	ExpressionNode node, left, right;
}
{
  ( left = UnaryExp() { node = left; } )
  ( ( "*" { operator = Operators.TS; } 
    | "/" { operator = Operators.DV; }
    | "%" { operator = Operators.MD; } ) 
  ( right = UnaryExp() )
		{ left = node = new MultiplicativeExpNode(left, right, operator); } )*

	{ return node; }
}

ExpressionNode UnaryExp() :
{
	ExpressionNode node;
}
{
 ( ( node = UnaryPlusExp() )
 |
   ( node = UnaryMinusExp() )
 |
   ( node = PreIncrementExp() )
 |
   ( node = PreDecrementExp() )
 |
   ( node = UnaryExpressionNotPlusMinus() ) )

	{ return node; }
}

ExpressionNode UnaryPlusExp() :
{
	ExpressionNode left;
}
{
	"+" ( left = UnaryExp() )

	{ return new UnaryPlusExpNode(left); } 
}

ExpressionNode UnaryMinusExp() :
{
	ExpressionNode left;
}
{
	"-" ( left = UnaryExp() )

	{ return new UnaryMinusExpNode(left); } 
}

ExpressionNode PreIncrementExp() :
{
	ExpressionNode left;
}
{
  "++" ( left = PrimaryExp() )

	{ return new PreIncrementExpNode(left); } 
}

ExpressionNode PreDecrementExp() :
{
	ExpressionNode left;
}
{
  "--" ( left = PrimaryExp() )

	{ return new PreDecrementExpNode(left); } 
}

ExpressionNode UnaryExpressionNotPlusMinus() :
{
	ExpressionNode node;
}
{
( ( node = UnaryNotExp() )
 |
  ( node = UnaryNegExp() )
 |
   LOOKAHEAD( CastLookahead() )		// TODO
  ( node = CastExp() )
 |
  ( node = PostfixExp() ) )

	{ return node; }
}

ExpressionNode UnaryNotExp() :
{
	ExpressionNode left;
}
{
	"!" ( left = UnaryExp() )

	{ return new UnaryNotExpNode(left); } 
}

ExpressionNode UnaryNegExp() :
{
	ExpressionNode left;
}
{
	"~" ( left = UnaryExp() )

	{ return new UnaryNegExpNode(left); } 
}

/*
 * This production is to determine lookahead only.  The LOOKAHEAD specifications
 * below are not used, but they are there just to indicate that we know about
 * this.
 */
void CastLookahead() :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveTypeExp()
 |
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
 |
  "(" Name() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" 
	| "new" | Literal() )
}

ExpressionNode PostfixExp() :
{
	ExpressionNode node;
}
{
  ( node = PrimaryExp() ) [ "++" { node = new PostIncrementExpNode(node); }
						  | "--" { node = new PostDecrementExpNode(node); } ]

	{ return node; }
}

ExpressionNode CastExp() :
{
	Type type;
	Symbol name;
	int dims = 0;
	ExpressionNode left;
}
{
  ( LOOKAHEAD(2)
  "(" ( type = PrimitiveTypeExp() ) ( "[" "]" { dims++; } )* ")" 
	  ( left = UnaryExp() ) 
 |
  "(" ( name = ResolvedName() { type = new ClassType(name); } ) 
  ( "[" "]" { dims++; } )* ")" 
  ( left = UnaryExpressionNotPlusMinus() ) )

	{ 
		if (dims > 0) {	
			type = new ArrayType(type, dims);
		}
		return new CastExpNode(left, type); 
	}
}

ExpressionNode PrimaryExp() :
{
	Symbol symbol;
	ExpressionNode left = null;
	ExpressionNode node = null; 

}
{
 ( ( left = Literal() ) 
   ( left = PrimarySuffix(left) )*
        {
          node = left;
	} 
 |
   <IDENTIFIER> { left = classifySimpleName(new Symbol(token.image)); }
		( left = PrimarySuffix(left) )*
	{
		if (left instanceof PackageExpNode) {
			symbol = ((PackageExpNode) left).toSymbol();
			
			// This must be a field expression (maybe a forward ref)

			ExpressionNode enode = (symbol.nOfFields() == 1) ? 
				(ExpressionNode) new ThisExpNode(className_d) :
				(ExpressionNode) new TypeExpNode(symbol.pathName());
			node = new FieldExpNode(enode, new Symbol(token.image), methodNode_d); 
		}
		else {
			node = left;
		}
	}
 |
   "this" { left = new ThisExpNode(className_d); } 
		( left = PrimarySuffix(left) )*
	{
		node = left;
	}
 |
   "super" "." <IDENTIFIER> 
	{ 
		left = new FieldExpNode(new SuperExpNode(superName_d), new Symbol(token.image),
			methodNode_d); 
	}
	( left = PrimarySuffix(left) )*
	{
		node = left;
	}
 |
   "(" ( left = Expression() ) ")" ( left = PrimarySuffix(left) )*
	{
		node = left;
	}
 |
   ( left = AllocationExp() ) ( left = PrimarySuffix(left) )* 
	{
		node = left;
	} )

	{ 
		recordSourceCoord(node, getToken(1));
		return node; 
	}
}

ExpressionNode PrimarySuffix(ExpressionNode left) :
{
	Vector args;
	Symbol prefix, name;
	ExpressionNode node = null;
	ExpressionNode right = null;
}
{
 ( "[" ( right = Expression() ) "]"
	{
		node = new ArrayExpNode(left, right);
	}
 |
   "." <IDENTIFIER>
	{
		name = new Symbol(token.image);

		if (left instanceof PackageExpNode) {
			prefix = ((PackageExpNode) left).toSymbol();

			right = classifySimpleName(name);

			if (right instanceof TypeExpNode) {
				node = new TypeExpNode(prefix, token.image);
			}
			else if (right instanceof PackageExpNode ||
					 right instanceof FieldExpNode) { 		// is this OK ??
				node = new PackageExpNode(prefix, token.image);
			}
			else {
				Espresso.internalError();
			}
		} 
		else {
		     if (left instanceof Literal) {
		        // check that left is a string 
			// wrap left with an allocation express
			if (left instanceof StringLiteral) {
			   Vector args1 = new Vector();
			   args1.addElement(left);
			   left = new AllocationExpNode(
				    new ClassType("java.lang.String"), args1, false);
		        }
		        else {
			   // We have an error
			   recordSourceCoord(left, getToken(1));
			   ErrorMsg error = new ErrorMsg(ErrorMsg.TYINVMET_ERR, left);	
			   errors_d.addElement(error.toString(name));		
		        }
		     }
		     node = new FieldExpNode(left, name, methodNode_d);
		}
	}
 |
   ( args = Arguments() )
	{
		// If the name is ambiguous, then it must be a method

		if (left instanceof FieldExpNode) {
			node = new MethodExpNode(left, args, methodNode_d);
			return node;
		}

		String path = null;

		if (left instanceof PackageExpNode) {
			name = ((PackageExpNode) left).name_d;
			path = name.pathName();
		}
		else if (left instanceof TypeExpNode) {
			name = ((TypeExpNode) left).name_d;
			path = name.pathName();
		}
		else if (left instanceof LocalExpNode) {
			name = ((LocalExpNode) left).name_d;
			path = name.pathName(3); 			// Remove scope and method name
		}
		else if (left instanceof FormalExpNode) {
			name = ((FormalExpNode) left).name_d;
			path = name.pathName(3); 			// Remove scope and method name
		}
		else {
			name = null;
			Espresso.internalError();
		}

		ExpressionNode enode = path.equals("") ? 
				(ExpressionNode) new ThisExpNode(className_d) : 
				(ExpressionNode) new TypeExpNode(path);
		node = new MethodExpNode(new FieldExpNode(enode, name.baseName(), 
			methodNode_d), args, methodNode_d);
	} )

	{ return node; }
}

ExpressionNode Literal() :
{
	int last;
	String literal;
	ExpressionNode node = new IntegerLiteral(new Integer(0));	// temporary
	recordSourceCoord(node, getToken(1));
}
{
 ( <INTEGER_LITERAL>
  {
	char ch;
	literal = token.image;
	last = literal.length() - 1;

	int radix = 10;

	if (last > 0 && literal.charAt(0) == '0') {
		ch = literal.charAt(1);
		if (ch != 'L' && ch != 'l') {
			radix = (ch == 'x' || ch == 'X') ? 16 : 8;
			literal = literal.substring(radix / 8);		// neat !
			last = literal.length() - 1;
		}
	}
			
	if (last >= 0) {
		ch = literal.charAt(last);
		if (ch == 'L' || ch == 'l') {
			try {
				literal = literal.substring(0, last);
				Long value = new Long(Long.parseLong(literal, radix));
				node = new LongLiteral(value);
			} 
			catch (NumberFormatException e) {
				if (radix != 10) {
					int len = literal.length();
					int hd  = Character.digit(literal.charAt(0), radix);

					if (radix == 16 && len <= 16 || 
						radix == 8  && (len < 22 || len == 22 && hd <= 1))
					{
						BigInteger bigint = new BigInteger(literal, radix);
						node = new LongLiteral(new Long(bigint.longValue()));
						return node;
					}
				}

				// Error invalid literal
				ErrorMsg error = new ErrorMsg(ErrorMsg.INVACONS_ERR, node);	
				errors_d.addElement(error.toString(token.image));		
			}
		} else {
			try {
				Integer value = new Integer(Integer.parseInt(literal, radix));
				node = new IntegerLiteral(value);
			} 
			catch (NumberFormatException e) {
				if (radix != 10) {
					int len = literal.length();
					int hd  = Character.digit(literal.charAt(0), radix);

					if (radix == 16 && len <= 8 || 
						radix == 8  && (len < 11 || len == 11 && hd <= 3))
					{
						BigInteger bigint = new BigInteger(literal, radix);
						node = new IntegerLiteral(new Integer(bigint.intValue()));
						return node;
					}
				}

				// Error invalid literal
				ErrorMsg error = new ErrorMsg(ErrorMsg.INVACONS_ERR, node);	
				errors_d.addElement(error.toString(token.image));		
			}
		}
	}
	else {
		Espresso.internalError();
	}
  }
|
  <FLOATING_POINT_LITERAL>
  {
	literal = token.image;
	last = literal.length() - 1;

	try {
		switch (literal.charAt(last)) {
		case 'f':
		case 'F':
			literal = literal.substring(0, last);
			node = new FloatLiteral(new Float(literal));
		break;
		case 'd':
		case 'D':
			literal = literal.substring(0, last);
			/* falls through */
		default:
			node = new DoubleLiteral(new Double(literal));
		break;
		}
	} catch (NumberFormatException e) {
		Espresso.internalError();				// oops - TODO
	}
  }
|
  <CHARACTER_LITERAL>
  {
	/*
   	 * Use a temporary StringLiteral to encode the char.
   	 */
	literal = token.image;
	StringLiteral temp = new StringLiteral(literal.substring(1, 
		literal.length() - 1));
	node = new CharacterLiteral(new Character(temp.charAt(0)));
  }
|
  <STRING_LITERAL>
  {
	literal = token.image;
	node = new StringLiteral(literal.substring(1, literal.length()-1));
  }
|
  ( node = BooleanLiteral() )
|
  ( node = NullLiteral() ) )

	{ return node; }
}

ExpressionNode BooleanLiteral() :
{}
{
  "true"	{ return new BooleanLiteral(new Boolean(true)); }
|
  "false"	{ return new BooleanLiteral(new Boolean(false)); }
}

ExpressionNode NullLiteral() :
{}
{
  "null"	{ return new NullLiteral(); }
}

Vector Arguments() :
{
	Vector args = null;
}
{
  "(" [ args = ArgumentList() ] ")"

	{ return args; }
}

Vector ArgumentList() :
{
	ExpressionNode exp;
	Vector args = new Vector();
}
{
  ( exp = Expression() ) { args.addElement(exp); } 
  ( "," ( exp = Expression() ) { args.addElement(exp); } )*

	{ return args; }
}

ExpressionNode AllocationExp() :
{
	Vector args;
	boolean array = true;
	Symbol name; Type type;
	ExpressionNode node = null;
}
{
 ( LOOKAHEAD(2)
  "new" ( type = PrimitiveTypeExp() ) ( args = ArrayDimensions() )
	{ 
		node = new AllocationExpNode(type, args, array); 
	}
 |
  "new" ( name = ResolvedName() ) ( ( args = Arguments() ) { array = false; } 
		| ( args = ArrayDimensions() ) )
	{
		node = new AllocationExpNode(new ClassType(name), args, array);
	} )

	{ return node; }
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
Vector ArrayDimensions() :
{
	ExpressionNode exp;
	Vector args = new Vector(5);
}
{
  ( LOOKAHEAD(2) "[" ( exp = Expression() ) { args.addElement(exp); } "]" )+ 
	( LOOKAHEAD(2) "[" "]" { args.addElement(new NullLiteral()); } )*

	{ return args; }
}


/*
 * Statement syntax follows.
 */

StatementNode Statement(boolean newScope) :
{
	StatementNode node = null;
}
{
( LOOKAHEAD(2)
  node = LabeledStatement()
|
  node = Block(newScope)
|
  node = EmptyStatement()
|
  node = StatementExp() ";"
|
  node = SwitchStatement()
|
  node = IfStatement()
|
  node = WhileStatement()
|
  node = DoStatement()
|
  node = ForStatement()
|
  node = BreakStatement()
|
  node = ContinueStatement()
|
  node = ReturnStatement()
|
  node = ThrowStatement()
|
  node = SynchronizedStatement()
|
  node = TryStatement() )

 { return node; }
}

LabeledStatementNode LabeledStatement() :
{
	LabeledStatementNode node = new LabeledStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  ( <IDENTIFIER> { node.label_d = new Symbol(token.image); 
				   symbolTable_d.addLabel(node.label_d, node); } )
  ( ":"  )
  ( node.statement_d = Statement(true) )

  	{ 
		if (node.statement_d instanceof LabeledStatementNode) {
			LabeledStatementNode lnode = (LabeledStatementNode) node.statement_d;
			symbolTable_d.addLabel(node.label_d, lnode);		// overwrites
		}
		return node; 
	}

}

BlockNode Block(boolean newScope) :
{
	StatementNode stmt = null;
	BlockNode node = new BlockNode();
	recordSourceCoord(node, getToken(1));

	// Start a new scope if needed
	if (newScope) scopes_d.pushInteger(counter_d.next());
}
{
  "{" ( stmt = BlockStatement(true)  { node.stmts_d.addElement(stmt); } )* "}"

	{ 
		// End this scope
		if (newScope) scopes_d.popInteger();
		return node; 
	}
}

StatementNode BlockStatement(boolean newScope) :
{
	StatementNode node;
}
{
 ( LOOKAHEAD(TypeExp() <IDENTIFIER>)
   node = LocalVarDeclaration() ";"
 |
   node = Statement(newScope) )

  { return node; }
}

StatementNode LocalVarDeclaration() :
{
	VariableDeclaratorNode var;
	Integer scope = scopes_d.peekInteger();
	LocalVarDeclarationNode node = new LocalVarDeclarationNode();
	recordSourceCoord(node, getToken(1));
}
{
  ( node.type_d = TypeExp() )
  ( var =  VariableDeclarator(false) ) { node.locals_d.addElement(var); } 
  ( "," ( var = VariableDeclarator(false) ) { node.locals_d.addElement(var); } )*

  	{ 
		node.encodeType();
		declareLocalVars(node);			// add vars to the symbol table
		return node; 
	}
}

StatementNode EmptyStatement() :
{
	StatementNode node = new EmptyStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  ";"
	{ return node; }
}

StatementExpNode StatementExp() :
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExp.
 */
{
	StatementExpNode node = new StatementExpNode();
	recordSourceCoord(node, getToken(1));
}
{
(	node.expression_d = PreIncrementExp()
|
	node.expression_d = PreDecrementExp()
|
  LOOKAHEAD( PrimaryExp() AssignmentOperator() )
	node.expression_d = Assignment()
|
	node.expression_d = PostfixExp() )

	{
		if (statementExp(node.expression_d)) {
			node.expression_d.statementExp_d = true;		// for code generation
		}
		else {
			ErrorMsg error = new ErrorMsg(ErrorMsg.NOTASTME_ERR, node);	
			errors_d.addElement(error.toString());		
		}
		return node; 
	}
}

LabeledStatementNode SwitchStatement() :
{
	/* 
	 * Wrap a switch statement inside a labeled statement with
	 * a fresh label.
	 */
	StatementNode stmt = null;
	SwitchLabelNode switchLabel = null;

	Integer label = labels_d.pushInteger(counter_d.next());
	LabeledStatementNode node = new LabeledStatementNode();
	node.label_d = new Symbol(label.toString());
	SwitchStatementNode snode = new SwitchStatementNode();
	node.statement_d = snode;

	symbolTable_d.addLabel(node.label_d, node);		// add it to the symbol table
	recordSourceCoord(snode, getToken(1));        
}
{
  "switch" "(" snode.expression_d = Expression() ")" "{"
    ( switchLabel = SwitchLabel() 
		{ snode.labels_d.addElement(switchLabel); }
	( stmt = BlockStatement(true) 
		{ switchLabel.statements_d.addElement(stmt);} )* )*
  "}"

	{ return node; }
}

SwitchLabelNode SwitchLabel() :
{
	SwitchLabelNode node = new SwitchLabelNode();
	recordSourceCoord(node, getToken(1));
}
{
  ( "case" ( node.expression_d = Expression() ) ":"
 |
    "default" ":" )

	{ return node; }
}

IfStatementNode IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
	IfStatementNode node = new IfStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  "if" "(" node.condition_d = Expression() 
  ")" node.thenStatement_d = Statement(true) 
  [ LOOKAHEAD(1) "else" node.elseStatement_d = Statement(true) ]
  { return node; }
}

LabeledStatementNode WhileStatement() :
{
	/* 
	 * Wrap a while statement inside a labeled statement with
	 * a fresh label.
	 */
	Integer label = labels_d.pushInteger(counter_d.next());
	LabeledStatementNode node = new LabeledStatementNode();
	node.label_d = new Symbol(label.toString());
	WhileStatementNode wnode = new WhileStatementNode();
	node.statement_d = wnode;		// link child

	symbolTable_d.addLabel(node.label_d, node);		// add it to the symbol table
	recordSourceCoord(wnode, getToken(1));
}
{
  "while" "(" wnode.condition_d = Expression() ")" 
  ( wnode.statement_d = Statement(true) )

	{ 
		labels_d.popInteger();
		return node; 
	}
}

LabeledStatementNode DoStatement() :
{
	/* 
	 * Wrap a do-while statement inside a labeled statement with
	 * a fresh label.
	 */
	Integer label = labels_d.pushInteger(counter_d.next());
	LabeledStatementNode node = new LabeledStatementNode();
	node.label_d = new Symbol(label.toString());
	DoStatementNode dnode = new DoStatementNode();
	node.statement_d = dnode;

	symbolTable_d.addLabel(node.label_d, node);		// add it to the symbol table
	recordSourceCoord(dnode, getToken(1));
}
{
  "do" ( dnode.statement_d = Statement(true) )
  "while" "(" dnode.condition_d = Expression() ")" ";"

	{ 
		labels_d.popInteger();
		return node; 
	}
}

LabeledStatementNode ForStatement() :
{
	/* 
	 * Wrap a for statement inside a labeled statement with
	 * a fresh label.
	 */
	Integer label = labels_d.pushInteger(counter_d.next());
	LabeledStatementNode node = new LabeledStatementNode();
	node.label_d = new Symbol(label.toString());
	ForStatementNode fnode = new ForStatementNode();
	node.statement_d = fnode;

	symbolTable_d.addLabel(node.label_d, node);		// add it to the symbol table
	recordSourceCoord(fnode, getToken(1));
}
{
  "for" "(" { scopes_d.pushInteger(counter_d.next()); }
      [ fnode.init_d = ForInit() ] 
  ";" [ fnode.bound_d = Expression() ] 
  ";" [ fnode.update_d = ForUpdate() ] ")" 
  ( fnode.statement_d = Statement(false) )	// no new scope

	{ 
		/*
		 * Wrap the update statement exp list using a labeled statement.
		 */
		if (fnode.update_d != null) {
			LabeledStatementNode update = new LabeledStatementNode();
			update.label_d = new Symbol(node.label_d, "for");		// for the continue
			update.statement_d = fnode.update_d;
			fnode.update_d = update;
			symbolTable_d.addLabel(update.label_d, update);
		}
		
		scopes_d.popInteger();
		return node; 
	}
}

StatementNode ForInit() :
{
	StatementNode node = null;
}
{
  (
    LOOKAHEAD( TypeExp() <IDENTIFIER> )
    node  =  LocalVarDeclaration()
    |
    node  = StatementExpList() )

	{ return node; }
}

StatementExpListNode StatementExpList() :
{
	StatementExpListNode node = new StatementExpListNode();
	StatementExpNode exp = null;
	recordSourceCoord(node, getToken(1));

}
{
  exp = StatementExp() { node.statementExps_d.addElement(exp);}
   ( "," exp = StatementExp() { node.statementExps_d.addElement(exp);})* 

	{ return node; }
}

StatementExpListNode ForUpdate() :
{
	StatementExpListNode node = null;
}
{
  node = StatementExpList()

	{ return node; }
}

BreakStatementNode BreakStatement() :
{
	BreakStatementNode node = new BreakStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  "break" [ <IDENTIFIER>  { node.label_d = new Symbol(token.image); } ] ";"

	{ 
		if (node.label_d == null) {
			if (labels_d.empty()) {
				ErrorMsg error = new ErrorMsg(ErrorMsg.BREAKNIL_ERR, node);	
				errors_d.addElement(error.toString());
			}
			else {
				// Set the default label to point to the closest loop.
				node.label_d = new Symbol(labels_d.peekInteger().toString());
			}
		}
		else if (symbolTable_d.lookupLabel(node.label_d) == null) {
			ErrorMsg error = new ErrorMsg(ErrorMsg.UNDEFLBL_ERR, node);	
			errors_d.addElement(error.toString(node.label_d.toString()));
		}
		return node; 
	}
}

StatementNode ContinueStatement() :
{
	ContinueStatementNode node = new ContinueStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  "continue" [ <IDENTIFIER> { node.label_d = new Symbol(token.image); } ] ";"

	{ 
		if (node.label_d == null) {
			if (labels_d.empty()) {
				ErrorMsg error = new ErrorMsg(ErrorMsg.CONTINIL_ERR, node);	
				errors_d.addElement(error.toString());
			}
			else {
				// Set the default label to point to the closest loop.
				node.label_d = new Symbol(labels_d.peekInteger().toString());
			}
		}
		else if (symbolTable_d.lookupLabel(node.label_d) == null) {
			ErrorMsg error = new ErrorMsg(ErrorMsg.UNDEFLBL_ERR, node);	
			errors_d.addElement(error.toString(node.label_d.toString()));
		}
		return node; 
	}
}

ReturnStatementNode ReturnStatement() :
{
	ReturnStatementNode node = new ReturnStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  "return" [ node.expression_d = Expression() ] ";"
	{ node.fetchResultType(methodName_d, symbolTable_d); return node; }
}

ThrowStatementNode ThrowStatement() :
{
	ThrowStatementNode node = new ThrowStatementNode ();
	recordSourceCoord(node, getToken(1));
}
{
  "throw" node.expression_d = Expression() ";"
	{ return node; }
}

SynchronizedStatementNode SynchronizedStatement() :
{
	SynchronizedStatementNode node = new SynchronizedStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  "synchronized" "(" node.expression_d = Expression() ")" 
  ( node.block_d = Block(true) )

	{ return node; }
}

LocalVarDeclarationNode CatchParameter() :
{
    VariableDeclaratorNode var = new VariableDeclaratorNode(false);
    Symbol name;
    Integer scope = scopes_d.peekInteger();
    LocalVarDeclarationNode node = new LocalVarDeclarationNode();

    // Add source code info for error reporting
    recordSourceCoord(var, getToken(1));
    recordSourceCoord(node, getToken(1));
}
{
    ( node.type_d = TypeExp() )
    ( name = VariableDeclaratorId() )  
	
	{ 
	    var.name_d = new Symbol(className_d, name);
	    
	    node.locals_d.addElement(var);

	    node.encodeType();
	    declareLocalVars(node);

	    return node; 
	}
}


TryStatementNode TryStatement() :
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
	BlockNode catchblock = null;
	LocalVarDeclarationNode formal = null;
	TryStatementNode node = new TryStatementNode();
	recordSourceCoord(node, getToken(1));
}
{
  "try" ( node.tryBlock_d = Block(true) )

  ( "catch"
	{ 
		scopes_d.pushInteger(counter_d.next());		// start scope
	}
  "(" formal = CatchParameter() ")"
	{
		node.formals_d.addElement(formal); 
	} 
  ( catchblock = Block(true) ) 
	{ 
	    node.catchBlocks_d.addElement(catchblock);
	    scopes_d.popInteger();						// end scope
	} )*

  [ "finally" node.finallyBlock_d = Block(true) ]
	{ 
		return node; 
	}
}

